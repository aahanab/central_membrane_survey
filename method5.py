# -*- coding: utf-8 -*-
"""Method5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1psn-6kIeQuaJkkPC2zbxDuMXaqXXKynt
"""

###############################################
# refined way of finding aluminum_pixels.
# aluminum_saturation = brightest_pixel - background_mean
# total_aluminum = total_value (grayscale)- num_pixels * background_mean
# aluminum_pixel = [total_aluminum / aluminum_saturation]
# Method 5

# Again we do this two ways: First I will apply this method to the new shifted and resized bounding boxes.
# Then I will apply it to the old code which is the unshifted bounding boxes.
# Finally to compare the method with the different sized and shifted bounding boxes, I will plot a 2D histogram.
# This is the final method which works the best.

import numpy as np
import cv2
import matplotlib.pyplot as plt

def calculate_pixel_histograms_new_5(image, points, lengths, widths, threshold=50):
    histograms = []

    # Define number of points in each cluster
    num_points_cluster1 = num_lines_cluster1
    num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

    for i, point in enumerate(points):
        x, y = point

        if i < num_points_cluster1:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2) - 20, int(y - width / 2) - 10
          end_x, end_y = int(x + length / 2) - 20, int(y + width / 2) - 10
        elif i < num_points_cluster2:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2) - 20, int(y - width / 2) - 10
          end_x, end_y = int(x + length / 2) - 20, int(y + width / 2) - 10
        else:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2), int(y - width / 2)
          end_x, end_y = int(x + length / 2), int(y + width / 2)

        # Extract the pixels within the box
        box_pixels = image[start_y:end_y, start_x:end_x]

        # Calculate the total grayscale value of all pixels in the box
        total_value = np.sum(box_pixels)

        # Calculate the background mean
        box_mean = np.mean(box_pixels)
        background_pixels = box_pixels[np.abs(box_pixels - box_mean) < 5]
        background_mean = np.mean(background_pixels)

        # Find the brightest pixel in the box and calculate aluminum saturation
        brightest_pixel = np.max(box_pixels)

        aluminum_saturation = brightest_pixel - background_mean

        # Subtract off numberofpixels*corrected_background_value
        num_pixels = box_pixels.shape[0] * box_pixels.shape[1]

        total_aluminum = total_value - num_pixels * background_mean

        # Calculate the aluminum pixel values and add them to the list of histograms
        aluminum_pixel = total_aluminum / aluminum_saturation
        aluminum_surface_area = aluminum_pixel / 6.7490556908 #scale factor
        histograms.append(aluminum_surface_area)

    return histograms


# Load the image in grayscale
image = cv2.imread("petal_54.jpg", cv2.IMREAD_GRAYSCALE)

# Load the points from the text file
points = []
with open("output_transformed_pixelcoord_54.txt", "r") as file:
    lines = file.readlines()[4:]  # skip the first 4 points which is the survey marks
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [20] * 76
cluster1_widths = [10] * 76

cluster2_lengths = [35] * 50
cluster2_widths = [20] * 50

cluster3_lengths = [60] * (len(points) - 76 - 50)
cluster3_widths = [35] * (len(points) - 76 - 50)

# Determine the number of lines for each cluster
num_lines_cluster1 = 76
num_lines_cluster2 = 50

# Determine the number of points in each cluster
num_points_cluster1 = len(cluster1_lengths)
num_points_cluster2 = num_points_cluster1 + len(cluster2_lengths)

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths.append(cluster1_lengths[i])
        widths.append(cluster1_widths[i])
    elif i < num_points_cluster2:
        lengths.append(cluster2_lengths[i - num_points_cluster1])
        widths.append(cluster2_widths[i - num_points_cluster1])
    else:
        lengths.append(cluster3_lengths[i - num_points_cluster2])
        widths.append(cluster3_widths[i - num_points_cluster2])

# Get the histograms for each box
histograms = calculate_pixel_histograms_new_5(image, points, lengths, widths)

# Plot the histogram
plt.hist(histograms, bins=50)
#plt.yscale('log')
plt.title("Aluminum pixel with shift: Method 5")
plt.xlabel("total_aluminum / aluminum_saturation")
plt.ylabel("Frequency")
plt.show()



################################################################################
# Now without the shift, not resized bounding boxes
################################################################################

import numpy as np
import numpy as np
import matplotlib.pyplot as plt

def calculate_pixel_histograms_old_5(image, points, lengths, widths, threshold=50):
    histograms = []

    # Define number of points in each cluster
    num_points_cluster1 = num_lines_cluster1
    num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

    for i, point in enumerate(points):
        x, y = point
        length, width = lengths[i], widths[i]
        start_x, start_y = int(x - length / 2), int(y - width / 2)
        end_x, end_y = int(x + length / 2), int(y + width / 2)


        # Extract the pixels within the box
        box_pixels = image[start_y:end_y, start_x:end_x]

        # Calculate the total grayscale value of all pixels in the box
        total_value = np.sum(box_pixels)

        # Calculate the background mean
        box_mean = np.mean(box_pixels)
        background_pixels = box_pixels[np.abs(box_pixels - box_mean) < 5]
        background_mean = np.mean(background_pixels)

        # Find the brightest pixel in the box and calculate aluminum saturation
        brightest_pixel = np.max(box_pixels)
        aluminum_saturation = brightest_pixel - background_mean

        # Subtract off numberofpixels*corrected_background_value
        num_pixels = box_pixels.shape[0] * box_pixels.shape[1]
        total_aluminum = total_value - num_pixels * background_mean

        # Calculate the aluminum pixel values and add them to the list of histograms
        aluminum_pixel = total_aluminum / aluminum_saturation
        aluminum_surface_area = aluminum_pixel / 6.7490556908
        histograms.append(aluminum_surface_area)

    return histograms

# Load the image in grayscale
image = cv2.imread("petal_54.jpg", cv2.IMREAD_GRAYSCALE)

# Load the points from the text file
points = []
with open("output_transformed_pixelcoord_54.txt", "r") as file:
    lines = file.readlines()[4:]
    #lines = file.readlines()
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [45]
cluster1_widths = [25]

cluster2_lengths = [65]
cluster2_widths = [35]

cluster3_lengths = [60]
cluster3_widths = [35]

# Determine the number of lines for each cluster
num_lines_cluster1 = 76
num_lines_cluster2 = 50

# Determine the number of points in each cluster
num_points_cluster1 = num_lines_cluster1
num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths += cluster1_lengths
        widths += cluster1_widths
    elif i < num_points_cluster2:
        lengths += cluster2_lengths
        widths += cluster2_widths
    else:
        lengths += cluster3_lengths
        widths += cluster3_widths


# Get the histograms for each box
histograms = calculate_pixel_histograms_old_5(image, points, lengths, widths)

# Plot the histogram
plt.hist(histograms, bins=50)
plt.title("Aluminum pixel without shift: Method 5")
plt.xlabel("total_aluminum / aluminum_saturation")
plt.ylabel("Frequency")
plt.show()


#################################################################################
# 2D plot comparing the shifted resized boxes with the unshifted bounding boxes.

import numpy as np
import matplotlib.pyplot as plt

old_histogram = calculate_pixel_histograms_old_5(image, points, lengths, widths)
new_histogram = calculate_pixel_histograms_new_5(image, points, lengths, widths)

plt.hist2d(old_histogram, new_histogram, bins=100)