# -*- coding: utf-8 -*-
"""Method4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fJ_ZOzRbncH97ZaohYmWQ8oLLadE6pxG
"""

# This is the code for using Method 4. First I apply this method to the old bounding boxes that were not shifted and resized.
# Then I will apply it to the new bounding boxes which are shifted and resixed.
# I also plot a 2D histogram to compare the Method with the old and new bounding box.



# Following is the old_histogram code without the shift
# corrected_value = total_value - num_pixels * background_mean

# Method 4
#############################################################

import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

def calculate_pixel_histograms_old_4(image, points, lengths, widths, threshold=50):
    histograms = []
    for i, point in enumerate(points):
        x, y = point
        length, width = lengths[i], widths[i]
        start_x, start_y = int(x - length / 2), int(y - width / 2)
        end_x, end_y = int(x + length / 2), int(y + width / 2)

        # Extract the pixels within the box
        box_pixels = image[start_y:end_y, start_x:end_x]

        # Calculate the total grayscale value of all pixels in the box
        total_value = np.sum(box_pixels)

        # Calculate the background mean
        box_mean = np.mean(box_pixels)
        background_pixels = box_pixels[np.abs(box_pixels - box_mean) < 5]
        background_mean = np.mean(background_pixels)

        # Subtract off numberofpixels*corrected_background_value
        num_pixels = box_pixels.shape[0] * box_pixels.shape[1]
        corrected_value = total_value - num_pixels * background_mean

        # Flatten the array of pixel differences
        corrected_value = corrected_value.flatten()

        # Add the corrected pixel differences for this box to the list of histograms
        histograms.extend(corrected_value.tolist())

    return histograms

# Load the image
image = cv2.imread("petal_54.jpg")

# Load the points from the text file
points = []
with open("output_transformed_pixelcoord_54.txt", "r") as file:
    lines = file.readlines()[4:]
    #lines = file.readlines()
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [45]
cluster1_widths = [25]

cluster2_lengths = [65]
cluster2_widths = [35]

cluster3_lengths = [60]
cluster3_widths = [35]

# Determine the number of lines for each cluster
num_lines_cluster1 = 72
num_lines_cluster2 = 54

# Determine the number of points in each cluster
num_points_cluster1 = num_lines_cluster1
num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths += cluster1_lengths
        widths += cluster1_widths
    elif i < num_points_cluster2:
        lengths += cluster2_lengths
        widths += cluster2_widths
    else:
        lengths += cluster3_lengths
        widths += cluster3_widths

# Get the histograms for each box
old_histogram = calculate_pixel_histograms_old_4(image, points, lengths, widths)

# Plot the histogram
plt.hist(old_histogram, bins=40)
plt.yscale('log')
plt.title("total grayscale value - #pixels*back_mean per box (w/o shift): Method 4")
plt.xlabel("grayscale value - #pixels*background_mean")
plt.ylabel("Frequency")
plt.show()

#######################################################################################
#######################################################################################
# Now its Method 4 applied to shifted and resized boxes:

import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

def calculate_pixel_histograms_new_4(image, points, lengths, widths, threshold=50):
    histograms = []
    # Define number of points in each cluster
    num_points_cluster1 = num_lines_cluster1
    num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

    for i, point in enumerate(points):
        x, y = point

        if i < num_points_cluster1:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2) - 20, int(y - width / 2) - 10
          end_x, end_y = int(x + length / 2) - 20, int(y + width / 2) - 10
        elif i < num_points_cluster2:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2) - 20, int(y - width / 2) - 10
          end_x, end_y = int(x + length / 2) - 20, int(y + width / 2) - 10  # add these lines
        else:
          length, width = lengths[i], widths[i]
          start_x, start_y = int(x - length / 2), int(y - width / 2)
          end_x, end_y = int(x + length / 2), int(y + width / 2)


        # Extract the pixels within the box
        box_pixels = image[start_y:end_y, start_x:end_x]

        # Calculate the total grayscale value of all pixels in the box
        total_value = np.sum(box_pixels)

        # Calculate the background mean
        box_mean = np.mean(box_pixels)
        background_pixels = box_pixels[np.abs(box_pixels - box_mean) < 5]
        background_mean = np.mean(background_pixels)

        # Subtract off numberofpixels*corrected_background_value
        num_pixels = box_pixels.shape[0] * box_pixels.shape[1]
        corrected_value = total_value - num_pixels * background_mean

        # Flatten the array of pixel differences
        corrected_value = corrected_value.flatten()

        # Add the corrected pixel differences for this box to the list of histograms
        histograms.extend(corrected_value.tolist())

    return histograms

# Loading images and the points
# shift is currently 20 units to the left and 10 units up
# IMPORTANT NOTE: Lengths and widths of the boxes have been altered

# Load the image
image = cv2.imread("petal_54.jpg")

# Load the points from the text file
points = []
with open("output_transformed_pixelcoord_54.txt", "r") as file:
    lines = file.readlines()[4:]  # skip the first 4 points
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [20] * 72
cluster1_widths = [10] * 72

cluster2_lengths = [35] * 54
cluster2_widths = [20] * 54

cluster3_lengths = [60] * (len(points) - 76 - 50)
cluster3_widths = [35] * (len(points) - 76 - 50)

# Determine the number of points in each cluster
num_points_cluster1 = len(cluster1_lengths)
num_points_cluster2 = num_points_cluster1 + len(cluster2_lengths)

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths.append(cluster1_lengths[i])
        widths.append(cluster1_widths[i])
    elif i < num_points_cluster2:
        lengths.append(cluster2_lengths[i - num_points_cluster1])
        widths.append(cluster2_widths[i - num_points_cluster1])
    else:
        lengths.append(cluster3_lengths[i - num_points_cluster2])
        widths.append(cluster3_widths[i - num_points_cluster2])

# Get the histograms for each box
new_histogram = calculate_pixel_histograms_new_4(image, points, lengths, widths)

# Plot the histogram
plt.hist(new_histogram, bins=30)
plt.yscale('log')
plt.title("total grayscale value - #pixels*back_mean per box w/ shift: Method 4")
plt.xlabel("grayscale value - #pixels*background_mean")
plt.ylabel("Frequency")
plt.show()

################################################################################
################################################################################
# Plotting the 2D histograms

import numpy as np
import matplotlib.pyplot as plt

old_histogram = calculate_pixel_histograms_old_4(image, points, lengths, widths)
new_histogram = calculate_pixel_histograms_new_4(image, points, lengths, widths)

plt.hist2d(old_histogram, new_histogram, bins=100)