# -*- coding: utf-8 -*-
"""shifted_resized_bounding boxes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lHLWEzNVlViFAgI8A5K-327dJ2gNrUPI
"""

# Following is the image of the bounding boxes after shift and after changing box size
# Upload all the coordinatesfrom the parsing code as well as teh respective petal image. 
# This code shifts the bounding boxes so it captures the stripes better

import cv2
from google.colab.patches import cv2_imshow

def draw_bounding_boxes(image, points, lengths, widths):
    result = image.copy()
    for i, point in enumerate(points):
        x, y = point
        if i < num_points_cluster1:
            length, width = lengths[i], widths[i]
            start_x, start_y = int(x - length / 2) - 20, int(y - width / 2) - 10
        elif i < num_points_cluster2:
            length, width = lengths[i], widths[i]
            start_x, start_y = int(x - length / 2)- 20, int(y - width / 2) - 10
        else:
            length, width = lengths[i], widths[i]
            start_x, start_y = int(x - length / 2), int(y - width / 2)
        end_x, end_y = int(x + length / 2), int(y + width / 2)
        cv2.rectangle(result, (start_x, start_y), (end_x, end_y), (255, 0, 0), 2)
    return result

# Load the image
image = cv2.imread("flipped_mono.jpg")

# Load the points from the text file
points = []
with open("output2.txt", "r") as file:
    lines = file.readlines()[4:]  # skip the first 4 points
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [20] * 72
cluster1_widths = [10] * 72

cluster2_lengths = [35] * 54
cluster2_widths = [20] * 54

cluster3_lengths = [60] * (len(points) - 72 - 54)
cluster3_widths = [35] * (len(points) - 72 - 54)

# Determine the number of points in each cluster
num_points_cluster1 = len(cluster1_lengths)
num_points_cluster2 = num_points_cluster1 + len(cluster2_lengths)

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths.append(cluster1_lengths[i])
        widths.append(cluster1_widths[i])
    elif i < num_points_cluster2:
        lengths.append(cluster2_lengths[i - num_points_cluster1])
        widths.append(cluster2_widths[i - num_points_cluster1])
    else:
        lengths.append(cluster3_lengths[i - num_points_cluster2])
        widths.append(cluster3_widths[i - num_points_cluster2])

# Draw the bounding boxes
result = draw_bounding_boxes(image, points, lengths, widths)

# Display the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()