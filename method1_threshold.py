# -*- coding: utf-8 -*-
"""Method1_threshold.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XcttZ0qTWq2vACCMQs3xYOqiLWN9gEWp
"""

# First we have to find the bounding box around the points

import cv2
from google.colab.patches import cv2_imshow

def draw_bounding_boxes(image, points, lengths, widths):
    result = image.copy()
    for i, point in enumerate(points):
        x, y = point
        length, width = lengths[i], widths[i]
        start_x, start_y = int(x - length / 2), int(y - width / 2)
        end_x, end_y = int(x + length / 2), int(y + width / 2)
        cv2.rectangle(result, (start_x, start_y), (end_x, end_y), (0, 0, 255), 2)
    return result

# Load the image
image = cv2.imread("petal_54.jpg")

# Load the points from the text file
points = []
with open("output_transformed_pixelcoord_54.txt", "r") as file:
    lines = file.readlines()[4:]
    for i, line in enumerate(lines):
        x, y, z = map(float, line.strip().split())
        points.append((x, y))

# Define the lengths and widths of the stripes for the different size clusters
cluster1_lengths = [45]
cluster1_widths = [25]

cluster2_lengths = [65]
cluster2_widths = [35]

cluster3_lengths = [60]
cluster3_widths = [35]

# Determine the number of lines for each cluster
num_lines_cluster1 = 76
num_lines_cluster2 = 50

# Determine the number of points in each cluster
num_points_cluster1 = num_lines_cluster1
num_points_cluster2 = num_points_cluster1 + num_lines_cluster2

# Assign the lengths and widths to each point based on the cluster
lengths = []
widths = []
for i, point in enumerate(points):
    if i < num_points_cluster1:
        lengths += cluster1_lengths
        widths += cluster1_widths
    elif i < num_points_cluster2:
        lengths += cluster2_lengths
        widths += cluster2_widths
    else:
        lengths += cluster3_lengths
        widths += cluster3_widths

# Draw the bounding boxes
result = draw_bounding_boxes(image, points, lengths, widths)

# Display the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Now we can find the aluminum pixels in each bounding box. This method utilizes a threshold method where it counts the box_pixels that are less than the threshold
# This would be all the aluminum pixels.
# It prints out the aluminum pixels as well as a histogram
# This was the first method we tried. We can do better!

import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import numpy as np


def calculate_pixel_histograms(image, points, lengths, widths, threshold=200):   
    histograms = []                                                                  
    for i, point in enumerate(points):               
        x, y = point                                 
        length, width = lengths[i], widths[i]        
        start_x, start_y = int(x - length / 2), int(y - width / 2)    
        end_x, end_y = int(x + length / 2), int(y + width / 2) 
     
        # Extract the pixels within the box
        box_pixels = image[start_y:end_y, start_x:end_x] 

        # Calculate the average pixel color
        box_mean = np.mean(box_pixels) 

        # Calculate the number of pixels brighter than the threshold
        num_bright_pixels = np.sum(box_pixels > threshold) 

        # Calculate the number of pixels darker than the threshold
        num_dark_pixels = np.sum(box_pixels < threshold)

        # Add the histogram for this box to the list of histograms
        histograms.append((num_dark_pixels, num_bright_pixels))

    return histograms

# Get the histograms for each box
histograms = calculate_pixel_histograms(image, points, lengths, widths) 

# Extract the number of "aluminum" pixels for each box
aluminum_pixels = [hist[0] for hist in histograms]

print(aluminum_pixels)

# Plot the histogram
plt.hist(aluminum_pixels, bins=40)
plt.title("Number of \"Aluminum\" Pixels per Box: Method 1")
plt.xlabel("Number of Pixels")
plt.ylabel("Frequency")
plt.show()